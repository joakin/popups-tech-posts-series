<!doctype html>
<html>

<head>

  <style>
    /*! ADAPTED
    Typeplate : Starter Kit
    URL ........... http://typeplate.com
    Version ....... 3.0.2
    Github ........ https://github.com/typeplate/starter-kit
    Authors ....... Dennis Gaebel (@gryghostvisuals) & Zachary Kain (@zakkain)
    License ....... Creative Commmons Attribution 3.0
    License URL ... https://github.com/typeplate/starter-kit/blob/master/license.txt
    */

    h1,
    h2,
    h3,
    h4,
    h5,
    h6 {
      text-rendering: optimizeLegibility;
      line-height: 1;
      margin-top: 0;
      color: #222;
    }

    blockquote+figcaption cite {
      display: block;
      font-size: inherit;
      text-align: right;
    }

    body {
      word-wrap: break-word;
    }

    pre code {
      word-wrap: normal;
    }

    body {
      -webkit-hyphens: auto;
      -ms-hyphens: auto;
      hyphens: auto;
      color: #444;
    }

    h1 {
      font-size: 2em;
      /* 2*16 = 32 */
    }

    h2 {
      font-size: 1.5em;
      /* 1.5*16 = 24 */
    }

    h3 {
      font-size: 1.17em;
      /* 1.17*16 = 18.72 */
    }

    h4 {
      font-size: 1em;
      /* 1*16 = 16 */
    }

    h5 {
      font-size: 0.83em;
      /* 0.83*16 = 13.28 */
    }

    h6 {
      font-size: 0.75em;
      /* 0.75*16 = 12 */
    }

    h1 {
      margin: 2.42424rem 0 1.454544rem;
    }

    h2 {
      margin: 2.0202rem 0 1.21212rem;
    }

    h3 {
      margin: 1.61616rem 0 1rem;
    }

    h4 {
      margin: 1.21212rem 0 1;
    }

    h5 {
      margin: 0.80808rem 0;
    }

    h6 {
      margin: 0.70707rem 0;
    }

    p {
      margin: auto auto 1.5rem;
    }

    small {
      font-size: 65%;
    }

    input,
    abbr,
    acronym,
    blockquote,
    code,
    kbd,
    q,
    samp,
    var {
      -webkit-hyphens: none;
      -ms-hyphens: none;
      hyphens: none;
    }

    pre {
      white-space: pre;
    }

    pre code {
      white-space: -moz-pre-wrap;
      white-space: pre-wrap;
    }

    code {
      white-space: pre;
      font-family: SF Mono, Consolas, Dejavu Sans Mono, Menlo, monospace;
    }

    abbr {
      -webkit-font-variant: small-caps;
      -moz-font-variant: small-caps;
      -ms-font-variant: small-caps;
      font-variant: small-caps;
      font-weight: 600;
      text-transform: lowercase;
      color: gray;
    }

    abbr[title]:hover {
      cursor: help;
    }

    /* FROM http://purecss.io/layouts/side-menu/  adapted to remove pure classes*/

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
      color: #444;
    }

    img {
      max-width: 100%;
      height: auto;
      display: block;
      margin: auto;
    }

    code,
    pre {
      background-color: #f5f5f5;
      color: #444;
      border-radius: 2px;
      text-shadow: 0px 1px 0px white;
      box-shadow: 0 1px 1px rgba(0, 0, 0, 0.15);
    }

    pre code {
      border: none;
      box-shadow: none;
    }

    pre {
      padding: 0.5em;
    }

    code {
      display: inline-block;
      padding: 0 0.5em;
      line-height: 1.4;
      font-size: 0.9em;
    }

    table {
      border-spacing: 0;
      margin-bottom: 1.5rem;
    }

    table th,
    table td {
      padding: 0.3em 0.7em;
    }

    table th {
      background-color: #f4f4f4;
      border-bottom: 2px solid #444;
    }

    table td {
      border: 1px solid #f5f5f5;
    }

    /* Add transition to containers so they can push in and out. */

    #layout,
    #menu,
    .menu-link {
      -webkit-transition: all 0.2s ease-out;
      -moz-transition: all 0.2s ease-out;
      -ms-transition: all 0.2s ease-out;
      -o-transition: all 0.2s ease-out;
      transition: all 0.2s ease-out;
    }

    /* This is the parent `<div>` that contains the menu and the content area. */

    #layout {
      position: relative;
      padding-left: 0;
    }

    #layout.active #menu {
      left: 250px;
      width: 250px;
    }

    #layout.active .menu-link {
      left: 250px;
    }

    /* The content `<div>` is where all your content goes. */

    .content {
      margin: 50px auto;
      padding: 0 2em;
      max-width: 80ex;
      line-height: 1.6em;
    }

    /*
    The `#menu` `<div>` is the parent `<div>` that contains the menu that
    appears on the left side of the page.
    */

    #menu {
      margin-left: -250px;
      /* "#menu" width */
      width: 250px;
      position: fixed;
      top: 0;
      left: 0;
      bottom: 0;
      z-index: 1000;
      /* so the menu or its navicon stays above all content */
      background: #f4f4f4;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
      font-size: 0.9em;
    }

    a,
    a * {
      text-decoration: none;
      color: #2483cc;
    }

    a:visited {
      text-decoration: none;
      color: #2483cc;
    }

    /* All anchors inside the menu should be styled like this. */

    #menu a {
      display: block;
      padding: 0.5em 0.5em;
    }

    #menu a:first-letter {
      text-transform: capitalize;
    }

    #menu ul {
      list-style-type: none;
      padding: 0;
      margin: 1em 0.5em;
    }

    #menu ul ul {
      margin-top: 0.5em;
      margin-left: 0.5em;
      border-left: 4px solid rgba(255, 255, 255, 0.5);
    }

    /* Change color of the anchor links on hover/focus. */

    #menu li a:hover,
    #menu li a:focus {
      background: rgba(255, 255, 255, 0.4);
    }

    /* This styles the selected menu item `<li>`. */

    #menu li a.active {
      background: rgba(0, 0, 0, 0.05);
    }

    /* This styles a link within a selected menu item `<li>`. */

    #menu li a.active {
      color: #222;
    }

    /* This styles the menu heading. */

    #menu li.heading {
      font-size: 0.9em;
      text-transform: uppercase;
      color: #000;
    }

    #menu li.heading>* {
      padding: 0.5em;
      display: block;
    }

    #menu li.heading a {
      color: #0c68af;
    }

    /* -- Dynamic Button For Responsive Menu -------------------------------------*/

    /*
    `.menu-link` represents the responsive menu toggle that shows/hides on
    small screens.
    */

    .menu-link {
      position: fixed;
      display: block;
      /* show this only on small screens */
      top: 0;
      left: 0;
      /* "#menu width" */
      background: #f4f4f4;
      font-size: 10px;
      /* change this value to increase/decrease button size */
      z-index: 10;
      width: 2em;
      height: auto;
      padding: 1.6em 1.2em;
      border-radius: 0 2px 2px 0;
    }

    .menu-link:hover {
      background: /* #f4f4f4 * 0.8 */
      #eee;
    }

    .menu-link span {
      position: relative;
      display: block;
    }

    .menu-link span,
    .menu-link span:before,
    .menu-link span:after {
      background-color: #555;
      width: 100%;
      height: 0.2em;
      border-radius: 1em;
    }

    .menu-link span:before,
    .menu-link span:after {
      position: absolute;
      margin-top: -0.6em;
      content: " ";
    }

    .menu-link span:after {
      margin-top: 0.6em;
    }

    /* Hides the menu at `48em`, but modify this based on your app's needs. */

    @media (min-width: 48em) {

      .header,
      .content {
        padding-left: 2em;
        padding-right: 2em;
      }

      #layout {
        padding-left: 250px;
        /* left col width "#menu" */
        left: 0;
      }
      #menu {
        left: 250px;
      }

      .menu-link {
        position: fixed;
        left: 250px;
        display: none;
      }

      #layout.active .menu-link {
        left: 250px;
      }
    }

    @media (max-width: 48em) {
      /* Only apply this when the window is small. Otherwise, the following case results in extra padding on the left:
       * Make the window small.
       * Tap the menu to trigger the active state.
       * Make the window large again.
       */
      #layout.active {
        position: relative;
        left: 250px;
      }
    }
  </style>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta charset="utf-8">
</head>

<body>
  <div id="layout">
    <!-- Menu toggle -->
    <a href="#menu" id="menuLink" class="menu-link">
      <!-- Hamburger icon -->
      <span></span>
    </a>
    <nav id="menu">
      <ul>
<li><a class="" href="../index.html">index</a></li>
<li class="heading"><span>tooling</span></li>
<ul>
<li><a class="" href="01-automatic-file-bundling.html">automatic file bundling</a></li>
<li><a class="" href="02-better-minification-for-frontend-sources.html">better minification for frontend sources</a></li>
<li><a class="active" href="03-fast-and-isolated-JS-unit-tests.html">fast and isolated JS unit tests</a></li>
</ul>
<li class="heading"><span>code patterns & architecture</span></li>
<ul>
<li><a class="" href="../02-code-patterns-&-architecture/01-factory-functions.html">factory functions</a></li>
</ul>
</ul>
    </nav>
    <article id="main" class="content">
      <h2>Fast and isolated JS unit tests</h2>
<h3>Intro</h3>
<p>For testing frontend code, MediaWiki provides a browser based QUnit setup. For
running the tests, you have to spin up MediaWiki, usually through vagrant, and
load Special:JavaScriptTest in your browser, which will run all the QUnit tests
for all the extensions and MediaWiki itself. From then on, you can filter by
module or string, hide passed tests, and a few other things like select to load
the assets in production mode or development mode (<code>debug=true</code>).</p>
<p>Like any testing strategy, this setup comes with tradeoffs. Specifically, there
are a couple of big problems that we have had when working on the frontend code,
which we set out to address when working in <code>Extension:Popups</code>:</p>
<ol>
<li>Tests take a long time to run</li>
<li>It is very hard to write isolated unit tests</li>
</ol>
<h4>Tests usually take a long time to run</h4>
<p>With this setup, tests have to go through to the MediaWiki server,
ResourceLoader, and then run in the browser. This is especially noticeable in
development mode, which we often enable to get readable stack traces and error
messages on test failures, but makes the test run take a lot longer.</p>
<p>There are also big startup costs, for powering up vagrant and the whole system.</p>
<p>As a result of this, writing tests is costlier than it should be, which
discourages developers to write and run tests, and over time ends up affecting
the quality of our code and QUnit test suites. It also puts significant barriers
to TDD style workflows, which rely on constantly running tests and require a
fast feedback cycle with the developer.</p>
<p><code>TODO: Add image or video</code></p>
<h4>It is very hard to write isolated unit tests</h4>
<p>In this environment, the real MediaWiki, global state, and the browser
environment are available. As a result, tests are written often as integration
tests, relying on implicit behavior, modules and state being available to
perform the testing.</p>
<p>This is not a problem by itself, integration tests are important and have very
valid use cases and a place in the testing process, but this environment itself
makes it extremely complicated to write isolated unit tests, because of all the
global state, variables, and existing loaded code.</p>
<p>As a result, tests written end up coupled to implicit behavior and state, which
makes them very brittle or overly verbose because of the extensive mocking, and
most of them are big integration tests, which makes them slower to run. All of
this adds up to the previous point, making it an even slower moving setup for
writing tests, with the same outcomes.</p>
<p><code>TODO: Find and add an example snippet with the boilerplate required for test set up and tear down.</code></p>
<h3>Requirements</h3>
<p>Given that:</p>
<ul>
<li>Untested code is unmaintained</li>
<li>Tests that run slow are never run</li>
<li>Monolithic integration tests are slow to write, read, modify, debug, and
execute; isolated unit tests are the opposite</li>
<li>Code that is difficult to test in isolation may be indicative of functional
concerns</li>
<li>Efficient tests greatly contribute to efficient development</li>
</ul>
<p>We need a way to write tests for our frontend JavaScript that:</p>
<ul>
<li>Encourage and enforce isolation
<ul>
<li>Without global state or a full MediaWiki environment running</li>
</ul>
</li>
<li>Start up and run the tests very fast</li>
<li>Re-run tests when our source files change automatically, without having to
wait for the developer to go to the browser and run the tests</li>
<li>Indicate clearly when a failure occurs and where it is</li>
</ul>
<p>Additional considerations:</p>
<ul>
<li>We should rely on familiar tools, at least initially to ease transition and
migration of existing tests to the new setup</li>
</ul>
<h3>Solution</h3>
<p>We discussed options, and the solution we ended up on was:</p>
<ul>
<li>Running the test files in Node.js
<ul>
<li>For speed, ease of setup and running it in CI, and the isolated environment</li>
</ul>
</li>
<li>With <a href="https://www.npmjs.com/package/qunitjs">QUnit</a>, <a href="https://www.npmjs.com/package/jquery">jQuery</a>, <a href="https://www.npmjs.com/package/sinon">Sinon</a> and <a href="https://www.npmjs.com/package/jsdom">jsdom</a>
<ul>
<li>To ease migration of existing unit tests to this setup</li>
<li>Because of familiarity with the tools (like <em>Special:JavascriptTest</em>)</li>
</ul>
</li>
</ul>
<p>You can read some more details in the architecture design record <a href="https://github.com/wikimedia/mediawiki-extensions-Popups/blob/2ddf8a96d8df27d6b5e8b4dd8ef33581951db9fe/doc/adr/0007-prefer-running-qunit-tests-in-node-js.md">7. Prefer
running QUnit tests in Node.js</a>.</p>
<h3>Results</h3>
<p>We implemented a new npm script <code>test:node</code> that is run in CI as part of the
script <code>test</code> on the npm job of the extension.</p>
<p>Tests were slowly migrated to <code>tests/node-qunit</code> from <code>tests/qunit</code> if it was
possible to make them <em>isolated</em>. <em>Integration</em> tests were kept in <code>tests/qunit</code>
as it made sense since they used the MediaWiki environment more heavily.</p>
<p>We created a small wrapper around QUnit -<a href="https://github.com/joakin/mw-node-qunit/">mw-node-qunit</a>- that we’ve been
using, which essentially gives us a CLI tool that sets up QUnit with jsdom,
jQuery, and Sinon so that it was easier to migrate the QUnit tests in.</p>
<p>It was quite straight forward to migrate, especially since most of the
Extension:Popups tests from the refactor had been written in a TDD fashion, and
were already mostly isolated.</p>
<p>There was a bit of figuring out because eventually some pieces of code use
<code>mw.*</code> functions or helpers, so we created a <a href="https://github.com/wikimedia/mediawiki-extensions-Popups/blob/2ddf8a96d8df27d6b5e8b4dd8ef33581951db9fe/tests/node-qunit/stubs.js"><code>stubs.js</code></a> where we
created a few stub helpers for the tests.</p>
<p>We also kept a couple of tests as integration tests in <code>tests/qunit</code>, but
eventually we did some work to refactor the code and made unit tests for the new
code, so we got rid of the integration tests in MediaWiki entirely.</p>
<p>With this setup, tests run quite fast, and it is feasible (and we do) run them
in watch mode while developing, giving you fast feedback and running your code
on save, all from the terminal/editor.</p>
<p>The environment doesn’t have any global state, or implicit knowledge of
MediaWiki, which forces us to write properly isolated tests that don’t rely on
implicit behavior or state.</p>
<p>Finally, the move to a Node.js-based toolchain means we are easily able to
leverage other great open source tools without much fuss, for example, for code
coverage. We added another script -<a href="https://github.com/wikimedia/mediawiki-extensions-Popups/blob/2ddf8a96d8df27d6b5e8b4dd8ef33581951db9fe/package.json#L12"><code>coverage</code></a>- which just run the
test command, but with the code coverage tool <a href="https://istanbul.js.org/"><code>istanbul</code></a> first, and
just like that we got back coverage reports for the frontend code.</p>
<p>We recommend this approach for others wanting to improve how they test, and
would be happy to help you figure out if this approach would work for you. For
example, you can use this CLI runner, even if your JS sources just use globals
instead of common.js or ES modules.</p>
<h3>Problems</h3>
<p>Overall, the move has gone great and we don’t many issues to report.</p>
<p>When migrating existing tests, it is sometimes a bit tricky to figure out how to
move them to the isolated environment, since most of the <a href="https://doc.wikimedia.org/mediawiki-core/master/js/">MediaWiki JS
library</a> is not available as an npm package, so in some occasions we had to
restructure the code a bit to not implicitly assume as much of MediaWiki being
available, and other times we had to set up some stubs for the tests to run
well. This had the added benefit that the dependency on MediaWiki core libraries
is explicit in the tests, so we should notice when adding new dependencies or
changing them because of the failing tests, keeping the behavior and
dependencies explicit.</p>
<p>Another extra thing that we have been doing has been maintaining
<a href="https://github.com/joakin/mw-node-qunit/"><code>mw-node-qunit</code></a>, which has taken a bit of additional time.
Making sure our wrapper works well with qunitjs, and updating the dependency
versions to not fall behind and leverage improvements on the libraries.</p>
<p><code>TODO: Remove this paragraph ⬇️ once mw-node-qunit is fixed</code>. We also expect
some more work on the wrapper as to simplify our implementation and be able to
leverage the superior QUnit.js tap output and the rest of the CLI options like
filters. The good thing is that the CLI wrapper should be useful for any
Wikimedia projects as is.</p>
<p>We will also be looking into moving the repository to the Wikimedia organization
in GitHub if other teams or projects adopt this testing strategy.</p>
<h3>Conclusions</h3>
<p>This change has worked really well for us. We are able to run our tests really
fast, even without vagrant running. The environment is isolated and really good
for unit testing. The CLI wrapper had the specific helpers to ease migration
from the existing tests, so it was fairly painless to switch.</p>
<p>Because of all of these, the extension has excellent code coverage, developers
have an easier time contributing tests, and doing TDD is feasible. There is less
uncertainty when refactoring and adding features, and the codebase is easy to
work with. A big part of it is because of the unit testing story.</p>
<p>We’re looking forward to adopting the same approach in other repositories and
helping others do the same.</p>

    </article>
  </div>
  <script>
    // FROM http://purecss.io/js/ui.js
    (function (window, document) {

      var layout = document.getElementById('layout'),
        menu = document.getElementById('menu'),
        menuLink = document.getElementById('menuLink');

      function toggleClass(element, className) {
        var classes = element.className.split(/\s+/),
          length = classes.length,
          i = 0;

        for (; i < length; i++) {
          if (classes[i] === className) {
            classes.splice(i, 1);
            break;
          }
        }
        // The className is not found
        if (length === classes.length) {
          classes.push(className);
        }

        element.className = classes.join(' ');
      }

      menuLink.onclick = function (e) {
        var active = 'active';

        e.preventDefault();
        toggleClass(layout, active);
        toggleClass(menu, active);
        toggleClass(menuLink, active);
      };

    }(this, this.document));
  </script>
</body>

</html>